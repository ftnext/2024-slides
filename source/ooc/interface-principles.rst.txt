1️⃣インターフェースの2原則
======================================================================

SOLIDから2つ

⚠️Pythonにインターフェースはありません
--------------------------------------------------

* 「インターフェースを実装」は **文法にありません**
* 抽象基底クラス（の継承）や、Protocolで実現します
* 言語にないために、私は理解するのに非常に苦労しました

1️⃣インターフェース分離原則（ISP）
--------------------------------------------------

SOLIDのI

インターフェースとは、 **利用** 時の関心
--------------------------------------------------

* 利用時、つまり **使う** とき
* 1つのインターフェースに、利用時の関心 **複数を結合させない** （小さな部品）

セルフわからん殺し：利用時の関心複数の大きいインターフェース
------------------------------------------------------------

.. code-block:: python

    class DatabaseDriverInterface(metaclass=ABCMeta):
        @abstractmethod
        def write(self, key: str, data) -> None:
            ...

        @abstractmethod
        def read(self, key: str):
            ...

解決策：小さなインターフェースを組合せる
--------------------------------------------------

* read()メソッドがあることを伝える ``DataInputInterface``
* write()メソッドがあることを伝える ``DataOutputInterface``
* 2つを組合せた ``DatabaseDriverInterface``

ちょうぜつ本 5.5

組合せる例
--------------------------------------------------

.. code-block:: python

    class DataInputInterface(metaclass=ABCMeta):
        @abstractmethod
        def write(self, key: str, data) -> None:
            ...

    class DataOutputInterface(metaclass=ABCMeta):
        @abstractmethod
        def read(self, key: str):
            ...

    class DatabaseDriverInterface(DataInputInterface, DataOutputInterface):
        # DatabaseDriverInterfaceを継承したクラスはreadとwriteを実装する必要がある
        ...

`Python実装例の全容 <https://github.com/ftnext/transcendent-book-py/blob/4c2b8c0064aa67be6d98e239cfdb1430f1e59cc7/chapter5/multi_interface_drivers/db/interface.py>`__

.. readは持っている、writeは持っているとして処理が書ける

なぜインターフェースを小さくする？
--------------------------------------------------

* **使うときは概念の一部しか見えない** から
* fooメソッドがあるという使い方だけ伝えればよい

  * fooと一緒にbarメソッドもあるということはfooを使う上では不要

2️⃣依存性逆転原則（DIP）
--------------------------------------------------

SOLIDのD

（最小の）インターフェースに依存させる
--------------------------------------------------

* **使い方** （fooメソッドがある。 **抽象**）に依存
* fooメソッドが具体的にどう実装されているかは一切気にしない

作ると使うを分けた先に
--------------------------------------------------

.. code-block:: python

    def execute_ocr(client: ImageOcrClient | DocumentOcrClient) -> str:
        result = client.recognize(...)
        return result

    client = ImageOcrClient()
    return execute_ocr(client)

インターフェースを導入
--------------------------------------------------

.. code-block:: python

    def execute_ocr(client: OcrClientInterface) -> str:
        result = client.recognize(...)
        return result

画像を受け取れる ``recognize()`` メソッドを持つ

差し替え可能になっている
--------------------------------------------------

* ``recognize`` メソッドがある **別のクラス** （具象）を **注入** することもできる
* 作ると使うが一体になり、具象に依存していた状態からは天地の差

「作ると使うを分ける」から依存性逆転へ
--------------------------------------------------

* 最初は引数に切り出した
* 引数の共通の性質として、インターフェースを導入
* 結果、インターフェースに依存させられた！
