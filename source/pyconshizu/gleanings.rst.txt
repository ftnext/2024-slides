3️⃣落ち穂拾い
======================================================================

* ライブラリで ``NullHandler`` を使わない（アンチパターン）
* Logging Flow

3️⃣-1️⃣ ライブラリのロギングのアンチパターン
======================================================================

なぜ「``NullHandler`` 以外はいけません」なのか

⚠️ ``NullHandler`` 以外のハンドラを設定してみる
--------------------------------------------------

.. code-block:: python
    :emphasize-lines: 4

    import logging

    logger = logging.getLogger("mylib")
    logger.addHandler(logging.StreamHandler())

2重出力😱
--------------------------------------------------

.. code-block:: python

    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s | %(levelname)s | %(name)s:%(funcName)s:%(lineno)d - %(message)s",
    )

.. code-block:: txt

    想定通り
    2024-08-31 14:16:34,968 | INFO | antipattern_logging.add_non_nullhandler:awesome:8 - 想定通り

2重出力の裏にpropagate
--------------------------------------------------

* ``mylib`` ロガーのロギングレベル以上のメソッドが呼ばれた
* ``mylib`` ロガーのハンドラ（``StreamHandler``）が処理して出力
* 親のルートロガーに伝播し、 **ルートロガーのハンドラでも処理** して出力

`ライブラリのためのロギングの設定`_ の注釈📄
--------------------------------------------------

    ライブラリのロガーには、 NullHandler 以外のハンドラを追加しない ことを強く推奨します。これは、ハンドラの設定が、あなたのライブラリを使うアプリケーション開発者にも伝播するからです。

もう1例：ライブラリがルートロガーを触る
======================================================================

これもやってはいけません

⚠️ ライブラリで ``basicConfig()``
--------------------------------------------------

.. code-block:: python

    import logging

    logging.basicConfig(
        level=logging.DEBUG, format="%(levelname)s:%(name)s:%(message)s"
    )

``basicConfig()`` がルートロガーを設定するのは「一度だけ」
----------------------------------------------------------------------

    (略) ルートロガーに設定されたハンドラがあれば何もしません。(`logging.basicConfig()`_ 📄)

ライブラリがルートロガーにハンドラを設定してしまうと、 **アプリケーションコードで呼び出しても何も起こらない** 😭（詳しくは `ブログ記事 <https://nikkie-ftnext.hatenablog.com/entry/python-logging-basicconfig-configure-root-logger-without-handler>`__ に）

**ライブラリではルートロガーは触らない**
--------------------------------------------------

    あなたのライブラリから ルートロガーへ直接ログを記録しない ことを強く推奨します。

`ライブラリのためのロギングの設定`_ 📄

``logging.warning()`` なども全部 ``basicConfig()`` を呼んでます
----------------------------------------------------------------------

    if the root logger has no handlers, then ``basicConfig()`` is called, prior to calling debug on the root logger. (📄 `logging.debug() <https://docs.python.org/ja/3/library/logging.html#logging.debug>`__)

``basicConfig()`` 同様にライブラリで使ってはいけません

.. _Logging Flow: https://docs.python.org/ja/3/howto/logging.html#logging-flow

3️⃣-2️⃣ Logging Flow
======================================================================

`Logging Flow`_ 📄を読み解く

Pythonのloggingの構成要素
--------------------------------------------------

* ロガー
* ロギングレベル
* ハンドラ
* フォーマッタ
* **フィルタ** （👉 *Appendix*）

ロガーを構成する要素
--------------------------------------------------

* ロギングレベル
* ハンドラ（0個以上）
* *フィルタ* （0個以上）

ハンドラを構成する要素
--------------------------------------------------

* *ロギングレベル* （👉 *Appendix*）
* フォーマッタ（1個）
* *フィルタ* （0個以上）

なぜこんなに構成要素がある？
--------------------------------------------------

* **柔軟なロギング** を提供
* 例：ロガーに複数のハンドラを設定。ハンドラのロギングレベルを使って、レベルごとに異なる出力先へ出し分ける

    それぞれのハンドラで設定されるレベルは、そのハンドラがどのメッセージを転送するべきか決めます。(`ハンドラ（上級ロギングチュートリアル）`_ 📄)

`Logging Flow`_
======================================================================

構成要素がどのように組み合さって動くかを示す

一例：propagate（ただし抜粋）
--------------------------------------------------

* ライブラリのロガーのレベル以上の呼び出し
* そのロガーのハンドラがログレコードを処理
* ライブラリのロガーの親のハンドラにもログレコードが渡る（親のレベルは見ない）
